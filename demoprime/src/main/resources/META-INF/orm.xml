<?xml version="1.0" encoding="UTF-8"?>
<!--
 ! (c) Copyright 2005-2012 JAXIO, www.jaxio.com
 ! Source code generated by Celerio, a Jaxio product
 ! Want to use Celerio within your company? email us at info@jaxio.com
 ! Follow us on twitter: @springfuse
 ! Template pack-backend-jpa:src/main/resources/META-INF/orm.p.vm.xml
-->
<entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm/orm_2_0.xsd" version="2.0">
	<description><![CDATA[
		NOTE: You may override the JPA annotations of your Java entities in this file.
		This is also the standard place to declare your named queries.

		********************************************
		* ABOUT NAMED QUERIES and SearchParameters *
		********************************************
        
		Named query integration is almost transparent, it is done using
		the generated services and searchParameters.

		To execute a named query
		========================
		* Define a named query in this file (some example are provided) or via an annotation in your Entity class.

		* Pass the named query's name and the parameters, if any, to the searchParameters:
		   searchParameters.setNamedQuery("myNamedQuery");
		   searchParameters.addParameter("paramName", paramValue);

		* Use the xxxService that handles the Xxx entity that the named query should return.
			 For example:
			   xxxService.find(searchParameters) or
			   xxxService.find(xxxModel, searchParameters)

			   xxxService.findCount(searchParameters)
			   xxxService.findCount(xxxModel, searchParameters)

		When you define your named query the following magic parameters
		will be automatically replaced:
		:currentUserId ==> replaced with the id of the current user carried by
							  the UserContext (-1 if not available)
		:now			  ==> replaced with the current date
		:anyParameterName ==> replaced with the value with either
		   - the value of xxxModel.getAnyParameterName()
		   - the value returned by searchParameters.getParameters().get("anyParameterName")

		Dynamic order By support:
		=========================
		If the hint 'dynamic' is present and set to 'true'
		the query will be dynamically modified to take into account the orderBy
		information carried by the searchParameters.
        This is extremely usefuf when rendering sortable data to the view.        
        NOTE: When dynamic is true YOU MUST declare a 'query' hint having exactly the same value as the query tag.

		Dynamic Select count support:
		=============================
		Note that if you call xxxService.findCount(searchParameters) and that your
		named query starts with "from" instead of "select", the "select count(*) "
		will be dynamically appended so it returns what you expect.
	]]></description>
	<entity metadata-complete="false" class="fr.jaxio.demo.domain.Account">
		<!-- basic example with dynamic ordering support -->
		<named-query name="Account.selectAll">
			<query>from fr.jaxio.demo.domain.Account</query>
            <hint name="dynamic" value="true" />
            <hint name="query" value="from fr.jaxio.demo.domain.Account" />
			<hint name="org.hibernate.cacheable" value="true" />
		</named-query>
		<!-- the :currentUserId will be replaced automatically with the value returned by the UserContext -->
		<named-query name="getMyAccountOnlyExample">
			<query>from fr.jaxio.demo.domain.Account as account
			where account.id = :currentAccountId</query>
            <hint name="dynamic" value="true" />
            <hint name="query" value="from fr.jaxio.demo.domain.Account as account where account.id = :currentUserId" />
			<hint name="org.hibernate.cacheable" value="true" />
		</named-query>
		<named-native-query name="Account.selectAll.native" result-class="fr.jaxio.demo.domain.Account">
			<query>select {account.*} from ACCOUNT</query>
		</named-native-query>
	</entity>
</entity-mappings>